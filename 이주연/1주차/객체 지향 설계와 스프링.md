<h3 align="center"> 스프링 핵심 원리 - 기본편 </h3>
<h3 align="center"> 섹션 1. 객체 지향 설계와 스프링 </h3>


# **스프링이란?**

**☘️ 스프링 프레임워크**

- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술 : 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원

→ 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

**☘️ 스프링부트**

- Tomcat 같은 웹 서버를 내장, 별도의 웹 서버 설치 x
- 편리한 빌드 및 설정 - starter 종속성, 3rd parth 라이브러리 버전 자동 구성
- 모니터링 가능 - 메트릭, 상태확인, 외부 구성 등 프로덕션 준비 기능 제공

→ 스프링을 편리하게 사용할 수 있도록 지원 (= 스프링이 기반이다!)

**☘️ 스프링의 핵심**

- 자바의 가장 큰 특징 = 객체 지향 언어
- 좋은 **객체 지향 애플리케이션**을 개발할 수 있게 도와주는 프레임워크

<p align="center"> <img src="https://github.com/zzu-yaaa/Leets-Study-Spring-Basic/assets/110540359/4076f66c-3b6e-40a8-93d6-42d1351b758d"> </p> </br>

# **좋은 객체 지향 프로그래밍이란?**

**☘️ 객체 지향 특징**

- 추상화, 캡슐화, 상속, **다형성**

**☘️ 객체 지향 프로그래밍**

- 컴퓨터 프로그램을 명렁어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **객체**들의 **모임**으로 파악하고자 하는 것
- 각각의 **객체**는 **메시지**를 주고받고, 데이터 처리 가능 = **협력**
- 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만듦 - 대규모 소프트웨어 개발에 많이 사용

**☘️ 다형성**

**예시**

- **역할**과 **구현**으로 구분하여 이해
    - 클라이언트는 해당 역할을 구현하기 위한 구현체의 내부 상관 X
    - 아무튼 역할만 잘 수행하면 된다..
  ![image](https://github.com/zzu-yaaa/Leets-Study-Spring-Basic/assets/110540359/744db29a-6711-4edc-97d1-f63d9f90fd40)

**역할과 구현**

- 역할과 구현으로 구분시, 세상이 **단순**해지고 **유연**해지며 **변경** 편리
- 장점
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다
    - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다
    - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다
    - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다
- 자바
    - 역할 = 인터페이스, 구현 = 인터페이스를 구현한 클래스 or 구현 객체
    - 인터페이스 먼저 설계하고 구현 객체 생성 할 것
    - 인터페이스를 안정적으로 설계하는 것이 중요

**☘️ 자바의 다형성**

- 오버라이딩 가능
- 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능
  ![image](https://github.com/zzu-yaaa/Leets-Study-Spring-Basic/assets/110540359/4798b7a3-d4ac-45ba-aebb-d47d5e62380e)
→ 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능

**☘️ 스프링과 객체 지향**

- 다형성이 가장 중요
- 스프링은 다형성을 극대화해서 이용할 수 있도록 도와준다
- 스프링에서 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해 역할과 구현을 편리하게 다룰 수 있도록 지원

<p align="center">   <img src="https://github.com/zzu-yaaa/Leets-Study-Spring-Basic/assets/110540359/4076f66c-3b6e-40a8-93d6-42d1351b758d"> </p> </br>


# 좋은 객체 지향 설계의 5가지 원칙(SOLID)

☘️ **SOLID : 객체 지향 설계의 5가지 원칙**

- SRP : 단일 책임 원칙 (Single responsibility principle)
- OCP : 개방-폐쇄 원칙 (Open/closed principle)
- LSP : 리스코프 치환 원칙 (Liskov substitution principle)
- ISP : 인터페이스 분리 원칙 (Interfac segregation principle)
- DIP : 의존관계 역전 원칙 (Dependency inversion principle)

☘️ **SRP 단일 책임 원칙**

- 하나의 클래스는 하나의 책임만 가져야한다
- 책임의 기준은 모호, 중요한 기준은 변경
    - 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

🌟 **OCP 개방-폐쇄 원칙**

- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
- 다형성 활용
    - 인터페이스를 구현하기 위해 새로운 클래스를 만들어 새로운 기능 구현
    - 새롭게 생성하는 것은 변경이 아님!
- 문제점
    - 구현 객체(클래스)를 변경하려면 클라이언트 코드를 변경해야 한다
    - 다형성을 이용했지만 변경 발생 = OCP 깨짐
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자 필요
        
        → 스프링이 해준다 ~
        

**☘️ LSP 리스코프 치환 원칙**

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
- 컴파일 성공 여부를 넘어서서, 역할에 맞게 알맞은 구현이 필요하다
- EX) 자동차 인터페이스의 엑셀 = 앞으로 가는 기능 / 뒤로 가면 LSP 위반

**☘️ ISP 인터페이스 분리 원칙**

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 인터페이스가 명확해지고, 대체 가능성이 높아진다
- EX ) 자동차 인터페이스 → 운전 인터페이스 & 정비 인터페이스
- EX ) 사용자 클라이언트 → 운전자 클라이언트 & 정비사 클라이언트

🌟 **DIP 의존관계 역전 원칙**

- 추상화에 의존해야지, 구체화에 의존하면 안된다
- 구현 클래스에 의존 X, 인터페이스(역할)에 의존할 것

→ 다형성만으로는 OCP, DIP 지키기 어려움

<p align="center">   <img src="https://github.com/zzu-yaaa/Leets-Study-Spring-Basic/assets/110540359/4076f66c-3b6e-40a8-93d6-42d1351b758d"> </p> </br>


# 객체 지향 설계와 스프링

**☘️** 객체 지향 설계와 스프링

- 다형성 + OCP, DIP를 가능하게 지원
    - DI(Dependency Injection): 의존관계, 의존성 주입
    - DI 컨테이너 제공
- 클라이언트 코드의 변경 없이 기능 확장
- 이상적으로 모든 설계에 인터페이스 부여
    - 하지만 추상화라는 비용 발생하기 때문에 리팩토링으로 도입하는 것도 방법
<p align="center">   <img src="https://github.com/zzu-yaaa/Leets-Study-Spring-Basic/assets/110540359/4076f66c-3b6e-40a8-93d6-42d1351b758d"> </p> </br>
